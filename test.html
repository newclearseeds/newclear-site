<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Darts Doubles — 3-Set Lineup</title>
  <!-- Tailwind (CDN play mode; fine for quick use) -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50">
  <div id="root"></div>

  <!-- React & Babel (for inline JSX). For production, use option B. -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useMemo, useState, useEffect } = React;

    const PLAYERS = ["Dean","Wayne","Gabor","Mark","Jun","Grant","Kalien","Darren","Liam","BurwoodSpare","Elton","Debby","Patrick","Neil"];

    function PairSelect({ label, value, onChange, players }) {
      const handle = (key, v) => onChange({ ...value, [key]: v });
      const duplicateInPair = value.p1 && value.p1 === value.p2;
      return (
        <div className="grid grid-cols-1 md:grid-cols-3 gap-3 items-end">
          <div className="text-sm font-medium text-gray-700">{label}</div>
          <div className="flex gap-2">
            <div className="flex-1">
              <label className="block text-xs text-gray-500 mb-1">Player 1</label>
              <select className="w-full rounded-2xl border px-3 py-2 shadow-sm"
                value={value.p1} onChange={(e)=>handle("p1", e.target.value)}>
                <option value="">— Select —</option>
                {players.map(p => <option key={p} value={p} disabled={value.p2===p}>{p}</option>)}
              </select>
            </div>
            <div className="flex-1">
              <label className="block text-xs text-gray-500 mb-1">Player 2</label>
              <select className="w-full rounded-2xl border px-3 py-2 shadow-sm"
                value={value.p2} onChange={(e)=>handle("p2", e.target.value)}>
                <option value="">— Select —</option>
                {players.map(p => <option key={p} value={p} disabled={value.p1===p}>{p}</option>)}
              </select>
            </div>
          </div>
          <div className="text-xs md:text-sm">
            {duplicateInPair
              ? <span className="text-red-600">Players in a pair must be different.</span>
              : (value.p1 && value.p2)
                  ? <span className="text-green-700">Pair ready ✓</span>
                  : <span className="text-gray-500">Choose two players.</span>}
          </div>
        </div>
      );
    }

    function CoverageHint({ setValue, fromSet1 }) {
      if (!fromSet1) return null;
      const picked = new Set([
        setValue.A.p1,setValue.A.p2,setValue.B.p1,setValue.B.p2,setValue.C.p1,setValue.C.p2
      ].filter(Boolean));
      const need = {
        A: [fromSet1.A.p1, fromSet1.A.p2].filter(Boolean),
        B: [fromSet1.B.p1, fromSet1.B.p2].filter(Boolean),
        C: [fromSet1.C.p1, fromSet1.C.p2].filter(Boolean),
      };
      const missing = Object.entries(need)
        .filter(([_, names]) => names.length && !names.some(n => picked.has(n)))
        .map(([k, names]) => `${k}: ${names.join(" / ")}`);
      const ok = missing.length === 0;
      return (
        <div className={`text-xs mt-2 ${ok ? "text-green-700" : "text-amber-700"}`}>
          {ok ? "Coverage ok (contains someone from Set 1 A, B and C)"
              : `Missing coverage from → ${missing.join("; ")}`}
        </div>
      );
    }

    function SetCard({ setNo, value, onChange, coverageFrom }) {
      const playersUsed = useMemo(() => {
        const list = [value.A.p1,value.A.p2,value.B.p1,value.B.p2,value.C.p1,value.C.p2].filter(Boolean);
        const count = {}; list.forEach(p => count[p]=(count[p]||0)+1); return count;
      }, [value]);
      const warnDupWithinSet = Object.values(playersUsed).some(n => n>1);
      const setPair = (k, v) => onChange({ ...value, [k]: v });
      const clearSet = () => onChange({ A:{p1:"",p2:""}, B:{p1:"",p2:""}, C:{p1:"",p2:""} });

      return (
        <div className="rounded-2xl border shadow-sm p-4 md:p-6 bg-white print:border-0 print:shadow-none">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-lg md:text-xl font-semibold">Set {setNo}</h2>
            <button onClick={clearSet} className="text-xs md:text-sm px-3 py-1 rounded-2xl border hover:shadow no-print">Clear set</button>
          </div>
          <div className="space-y-4">
            <PairSelect label="Pair A" value={value.A} onChange={v=>setPair("A", v)} players={PLAYERS} />
            <PairSelect label="Pair B" value={value.B} onChange={v=>setPair("B", v)} players={PLAYERS} />
            <PairSelect label="Pair C" value={value.C} onChange={v=>setPair("C", v)} players={PLAYERS} />
          </div>
          <div className="mt-3 text-xs md:text-sm no-print">
            {warnDupWithinSet
              ? <div className="text-amber-700">Heads up: Someone is picked more than once in this set.</div>
              : <div className="text-gray-500">Tip: Spread players across pairs as needed.</div>}
          </div>
          {coverageFrom && <CoverageHint setValue={value} fromSet1={coverageFrom} />}
        </div>
      );
    }

    function PrintView({ sets, mode }) {
      const formatPair = (pair) => {
        if (!pair.p1 || !pair.p2) return '';
        return `${pair.p1} & ${pair.p2}`;
      };

      // Generate the rotation pattern based on mode
      const getRotationPairs = () => {
        const set1Pairs = [sets[1].A, sets[1].B, sets[1].C];
        if (mode === "home") {
          return [
            // Set 1: A, B, C
            set1Pairs,
            // Set 2: A, C, B (home rotation)
            [set1Pairs[0], set1Pairs[2], set1Pairs[1]],
            // Set 3: C, A, B
            [set1Pairs[2], set1Pairs[0], set1Pairs[1]]
          ];
        } else {
          return [
            // Set 1: A, B, C
            set1Pairs,
            // Set 2: B, A, C (away rotation)
            [set1Pairs[1], set1Pairs[0], set1Pairs[2]],
            // Set 3: B, C, A
            [set1Pairs[1], set1Pairs[2], set1Pairs[0]]
          ];
        }
      };

      const rotationPairs = getRotationPairs();

      return (
        <div className="print-only" style={{display: 'none'}}>
          <div style={{
            fontFamily: 'Arial, sans-serif',
            fontSize: '12px',
            lineHeight: '1.2',
            color: 'black',
            backgroundColor: 'white',
            padding: '20px',
            maxWidth: '210mm',
            margin: '0 auto'
          }}>
            <h1 style={{fontSize: '16px', fontWeight: 'bold', textAlign: 'center', marginBottom: '20px'}}>
              A GRADE TEAM SHEET
            </h1>
            
            <div style={{marginBottom: '15px'}}>
              <strong>The set number on the sheet MUST match the set number on DartConnect</strong>
            </div>
            
            <div style={{marginBottom: '15px'}}>
              <strong>Asterisk (*) throws first - In leg 3, the team that threw 2nd in leg one goes for the bull</strong>
            </div>
            
            <div style={{marginBottom: '20px'}}>
              <strong>Doubles - Best of 3 x 601</strong>
            </div>

            <table style={{
              width: '100%',
              borderCollapse: 'collapse',
              border: '2px solid black',
              fontSize: '11px'
            }}>
              <thead>
                <tr>
                  <th style={{border: '1px solid black', padding: '8px', backgroundColor: '#f0f0f0', fontWeight: 'bold'}}>Set</th>
                  <th style={{border: '1px solid black', padding: '8px', backgroundColor: '#f0f0f0', fontWeight: 'bold', minWidth: '120px'}}>Players (H)</th>
                  <th style={{border: '1px solid black', padding: '8px', backgroundColor: '#f0f0f0', fontWeight: 'bold', width: '40px'}}>Result</th>
                  <th style={{border: '1px solid black', padding: '8px', backgroundColor: '#f0f0f0', fontWeight: 'bold', width: '40px'}}>Result</th>
                  <th style={{border: '1px solid black', padding: '8px', backgroundColor: '#f0f0f0', fontWeight: 'bold', minWidth: '120px'}}>Players (A)</th>
                  <th style={{border: '1px solid black', padding: '8px', backgroundColor: '#f0f0f0', fontWeight: 'bold'}}>Set</th>
                </tr>
              </thead>
              <tbody>
                {[0, 1, 2].map(setIndex => 
                  ['A', 'B', 'C'].map((pairLetter, pairIndex) => {
                    const gameNumber = setIndex * 3 + pairIndex + 1;
                    const homePair = rotationPairs[setIndex][pairIndex];
                    const homeFormatted = formatPair(homePair);
                    const asterisk = pairLetter === 'A' || pairLetter === 'C' ? '*' : '';
                    const awayAsterisk = pairLetter === 'B' ? '*' : '';
                    
                    return (
                      <tr key={`${setIndex}-${pairIndex}`}>
                        <td style={{border: '1px solid black', padding: '8px', textAlign: 'center', fontWeight: 'bold'}}>
                          #{gameNumber}
                        </td>
                        <td style={{border: '1px solid black', padding: '8px'}}>
                          {pairLetter}{asterisk}
                        </td>
                        <td style={{border: '1px solid black', padding: '8px'}}></td>
                        <td style={{border: '1px solid black', padding: '8px'}}></td>
                        <td style={{border: '1px solid black', padding: '8px'}}>
                          {pairLetter}{awayAsterisk}
                        </td>
                        <td style={{border: '1px solid black', padding: '8px', textAlign: 'center', fontWeight: 'bold'}}>
                          #{gameNumber}
                        </td>
                      </tr>
                    );
                  })
                )}
              </tbody>
            </table>

            <div style={{marginTop: '20px', fontSize: '10px'}}>
              <div style={{marginBottom: '10px'}}>
                <strong>Team Setup ({mode.toUpperCase()} format):</strong>
              </div>
              <div style={{marginBottom: '5px'}}>
                <strong>Pair A:</strong> {formatPair(sets[1].A)}
              </div>
              <div style={{marginBottom: '5px'}}>
                <strong>Pair B:</strong> {formatPair(sets[1].B)}
              </div>
              <div style={{marginBottom: '5px'}}>
                <strong>Pair C:</strong> {formatPair(sets[1].C)}
              </div>
            </div>
          </div>
        </div>
      );
    }

    function App() {
      const [mode, setMode] = useState("home");
      const [sets, setSets] = useState({
        1: { A:{p1:"",p2:""}, B:{p1:"",p2:""}, C:{p1:"",p2:""} },
        2: { A:{p1:"",p2:""}, B:{p1:"",p2:""}, C:{p1:"",p2:""} },
        3: { A:{p1:"",p2:""}, B:{p1:"",p2:""}, C:{p1:"",p2:""} },
      });

      const applyHomeRules = () => {
        const s1 = sets[1]; setMode("home");
        setSets(prev => ({ ...prev, 2:{A:s1.A,B:s1.C,C:s1.B}, 3:{A:s1.C,B:s1.A,C:s1.B} }));
      };
      const applyAwayRules = () => {
        const s1 = sets[1]; setMode("away");
        setSets(prev => ({ ...prev, 2:{A:s1.B,B:s1.A,C:s1.C}, 3:{A:s1.B,B:s1.C,C:s1.A} }));
      };

      useEffect(() => { applyHomeRules(); /* once on load */ }, []);

      const updateSet = (n, v) => setSets(s => ({ ...s, [n]: v }));
      const fmtPair = (p) => (p.p1 && p.p2 ? `${p.p1} & ${p.p2}` : "—");
      const lineupText = useMemo(() => [
        `SET 1: A) ${fmtPair(sets[1].A)}  |  B) ${fmtPair(sets[1].B)}  |  C) ${fmtPair(sets[1].C)}`,
        `SET 2: A) ${fmtPair(sets[2].A)}  |  B) ${fmtPair(sets[2].B)}  |  C) ${fmtPair(sets[2].C)}`,
        `SET 3: A) ${fmtPair(sets[3].A)}  |  B) ${fmtPair(sets[3].B)}  |  C) ${fmtPair(sets[3].C)}`
      ].join("\n"), [sets]);

      const copy = async () => {
        try { await navigator.clipboard.writeText(lineupText); alert("Copied lineup to clipboard!"); }
        catch { alert("Could not copy. Select the text and copy manually."); }
      };

      const toCsv = () => {
        const rows = [
          ["Mode", mode.toUpperCase()], [],
          ["Set", "Pair", "Player 1", "Player 2"],
          ...[[1,sets[1]],[2,sets[2]],[3,sets[3]]].flatMap(([n,s]) => [
            [n,"A",s.A.p1||"",s.A.p2||""],
            [n,"B",s.B.p1||"",s.B.p2||""],
            [n,"C",s.C.p1||"",s.C.p2||""],
          ])
        ];
        const csv = rows.map(r => r.map(cell => {
          const v = String(cell ?? "");
          return (v.includes(",")||v.includes('"')||v.includes("\n")) ? `"${v.replaceAll('"','""')}"` : v;
        }).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a"); a.href = url; a.download = `darts_lineup_${mode}.csv`; a.click();
        URL.revokeObjectURL(url);
      };

      const printPage = () => window.print();

      return (
        <div className="min-h-screen bg-gray-50 p-4 md:p-8">
          <style>{`
            @media print { 
              body { -webkit-print-color-adjust: exact; print-color-adjust: exact; } 
              .no-print { display: none !important; } 
              .print\\:border-0 { border: 0 !important; } 
              .print\\:shadow-none { box-shadow: none !important; } 
              .print\\:bg-transparent { background: transparent !important; }
              .screen-only { display: none !important; }
              .print-only { display: block !important; }
            }
            @media screen {
              .print-only { display: none !important; }
              .screen-only { display: block !important; }
            }
          `}</style>

          <div className="screen-only">
            <div id="print-root" className="max-w-5xl mx-auto space-y-6">
              <header className="flex flex-col md:flex-row md:items-center md:justify-between gap-3">
                <h1 className="text-2xl md:text-3xl font-bold">Darts Doubles — 3-Set Lineup</h1>
                <div className="flex flex-wrap items-center gap-3 no-print">
                  <label className="text-sm">Mode</label>
                  <select className="rounded-2xl border px-3 py-2" value={mode} onChange={(e)=>setMode(e.target.value)}>
                    <option value="home">Home</option>
                    <option value="away">Away</option>
                  </select>
                  <button onClick={applyHomeRules} className="px-3 py-2 rounded-2xl border hover:shadow">Apply HOME rules</button>
                  <button onClick={applyAwayRules} className="px-3 py-2 rounded-2xl border hover:shadow">Apply AWAY rules</button>
                  <button onClick={copy} className="px-3 py-2 rounded-2xl border hover:shadow">Copy</button>
                  <button onClick={toCsv} className="px-3 py-2 rounded-2xl border hover:shadow">Export CSV</button>
                  <button onClick={printPage} className="px-3 py-2 rounded-2xl border hover:shadow">Print / Save PDF</button>
                </div>
              </header>

              <SetCard setNo={1} value={sets[1]} onChange={(v)=>updateSet(1, v)} />
              <SetCard setNo={2} value={sets[2]} onChange={(v)=>updateSet(2, v)} coverageFrom={sets[1]} />
              <SetCard setNo={3} value={sets[3]} onChange={(v)=>updateSet(3, v)} coverageFrom={sets[1]} />

              <div className="rounded-2xl border bg-white p-4 md:p-6 space-y-3 print:border-0 print:shadow-none">
                <div className="flex items-center justify-between">
                  <h3 className="font-semibold">Summary ({mode.toUpperCase()})</h3>
                </div>
                <pre className="text-sm bg-gray-100 rounded-xl p-3 overflow-x-auto whitespace-pre-wrap print:bg-transparent">{lineupText}</pre>
                <div className="text-xs text-gray-500">Coverage rule: Sets 2 & 3 must each include at least one player from <strong>each</strong> Set 1 pair (A, B, C). Use Apply HOME/AWAY to auto-fill, then tweak as needed.</div>
              </div>
            </div>
          </div>

          <PrintView sets={sets} mode={mode} />
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>