<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Darts Doubles — 3-Set Lineup</title>
  <!-- Tailwind (CDN play mode; fine for quick use) -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50">
  <div id="root"></div>

  <!-- React & Babel (for inline JSX). For production, use option B. -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useMemo, useState, useEffect } = React;

    const PLAYERS = ["Dean","Wayne","Gabor","Mark","Jun","Grant","Kalien","Darren"];

    function PairSelect({ label, value, onChange, players }) {
      const handle = (key, v) => onChange({ ...value, [key]: v });
      const duplicateInPair = value.p1 && value.p1 === value.p2;
      return (
        <div className="grid grid-cols-1 md:grid-cols-3 gap-3 items-end">
          <div className="text-sm font-medium text-gray-700">{label}</div>
          <div className="flex gap-2">
            <div className="flex-1">
              <label className="block text-xs text-gray-500 mb-1">Player 1</label>
              <select className="w-full rounded-2xl border px-3 py-2 shadow-sm"
                value={value.p1} onChange={(e)=>handle("p1", e.target.value)}>
                <option value="">— Select —</option>
                {players.map(p => <option key={p} value={p} disabled={value.p2===p}>{p}</option>)}
              </select>
            </div>
            <div className="flex-1">
              <label className="block text-xs text-gray-500 mb-1">Player 2</label>
              <select className="w-full rounded-2xl border px-3 py-2 shadow-sm"
                value={value.p2} onChange={(e)=>handle("p2", e.target.value)}>
                <option value="">— Select —</option>
                {players.map(p => <option key={p} value={p} disabled={value.p1===p}>{p}</option>)}
              </select>
            </div>
          </div>
          <div className="text-xs md:text-sm">
            {duplicateInPair
              ? <span className="text-red-600">Players in a pair must be different.</span>
              : (value.p1 && value.p2)
                  ? <span className="text-green-700">Pair ready ✓</span>
                  : <span className="text-gray-500">Choose two players.</span>}
          </div>
        </div>
      );
    }

    function CoverageHint({ setValue, fromSet1 }) {
      if (!fromSet1) return null;
      const picked = new Set([
        setValue.A.p1,setValue.A.p2,setValue.B.p1,setValue.B.p2,setValue.C.p1,setValue.C.p2
      ].filter(Boolean));
      const need = {
        A: [fromSet1.A.p1, fromSet1.A.p2].filter(Boolean),
        B: [fromSet1.B.p1, fromSet1.B.p2].filter(Boolean),
        C: [fromSet1.C.p1, fromSet1.C.p2].filter(Boolean),
      };
      const missing = Object.entries(need)
        .filter(([_, names]) => names.length && !names.some(n => picked.has(n)))
        .map(([k, names]) => `${k}: ${names.join(" / ")}`);
      const ok = missing.length === 0;
      return (
        <div className={`text-xs mt-2 ${ok ? "text-green-700" : "text-amber-700"}`}>
          {ok ? "Coverage ok (contains someone from Set 1 A, B and C)"
              : `Missing coverage from → ${missing.join("; ")}`}
        </div>
      );
    }

    function SetCard({ setNo, value, onChange, coverageFrom }) {
      const playersUsed = useMemo(() => {
        const list = [value.A.p1,value.A.p2,value.B.p1,value.B.p2,value.C.p1,value.C.p2].filter(Boolean);
        const count = {}; list.forEach(p => count[p]=(count[p]||0)+1); return count;
      }, [value]);
      const warnDupWithinSet = Object.values(playersUsed).some(n => n>1);
      const setPair = (k, v) => onChange({ ...value, [k]: v });
      const clearSet = () => onChange({ A:{p1:"",p2:""}, B:{p1:"",p2:""}, C:{p1:"",p2:""} });

      return (
        <div className="rounded-2xl border shadow-sm p-4 md:p-6 bg-white print:border-0 print:shadow-none">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-lg md:text-xl font-semibold">Set {setNo}</h2>
            <button onClick={clearSet} className="text-xs md:text-sm px-3 py-1 rounded-2xl border hover:shadow">Clear set</button>
          </div>
          <div className="space-y-4">
            <PairSelect label="Pair A" value={value.A} onChange={v=>setPair("A", v)} players={PLAYERS} />
            <PairSelect label="Pair B" value={value.B} onChange={v=>setPair("B", v)} players={PLAYERS} />
            <PairSelect label="Pair C" value={value.C} onChange={v=>setPair("C", v)} players={PLAYERS} />
          </div>
          <div className="mt-3 text-xs md:text-sm">
            {warnDupWithinSet
              ? <div className="text-amber-700">Heads up: Someone is picked more than once in this set.</div>
              : <div className="text-gray-500">Tip: Spread players across pairs as needed.</div>}
          </div>
          {coverageFrom && <CoverageHint setValue={value} fromSet1={coverageFrom} />}
        </div>
      );
    }

    function App() {
      const [mode, setMode] = useState("home");
      const [sets, setSets] = useState({
        1: { A:{p1:"",p2:""}, B:{p1:"",p2:""}, C:{p1:"",p2:""} },
        2: { A:{p1:"",p2:""}, B:{p1:"",p2:""}, C:{p1:"",p2:""} },
        3: { A:{p1:"",p2:""}, B:{p1:"",p2:""}, C:{p1:"",p2:""} },
      });

      const applyHomeRules = () => {
        const s1 = sets[1]; setMode("home");
        setSets(prev => ({ ...prev, 2:{A:s1.A,B:s1.C,C:s1.B}, 3:{A:s1.C,B:s1.A,C:s1.B} }));
      };
      const applyAwayRules = () => {
        const s1 = sets[1]; setMode("away");
        setSets(prev => ({ ...prev, 2:{A:s1.B,B:s1.A,C:s1.C}, 3:{A:s1.B,B:s1.C,C:s1.A} }));
      };

      useEffect(() => { applyHomeRules(); /* once on load */ }, []);

      const updateSet = (n, v) => setSets(s => ({ ...s, [n]: v }));
      const fmtPair = (p) => (p.p1 && p.p2 ? `${p.p1} & ${p.p2}` : "—");
      const lineupText = useMemo(() => [
        `SET 1: A) ${fmtPair(sets[1].A)}  |  B) ${fmtPair(sets[1].B)}  |  C) ${fmtPair(sets[1].C)}`,
        `SET 2: A) ${fmtPair(sets[2].A)}  |  B) ${fmtPair(sets[2].B)}  |  C) ${fmtPair(sets[2].C)}`,
        `SET 3: A) ${fmtPair(sets[3].A)}  |  B) ${fmtPair(sets[3].B)}  |  C) ${fmtPair(sets[3].C)}`
      ].join("\n"), [sets]);

      const copy = async () => {
        try { await navigator.clipboard.writeText(lineupText); alert("Copied lineup to clipboard!"); }
        catch { alert("Could not copy. Select the text and copy manually."); }
      };

      const toCsv = () => {
        const rows = [
          ["Mode", mode.toUpperCase()], [],
          ["Set", "Pair", "Player 1", "Player 2"],
          ...[[1,sets[1]],[2,sets[2]],[3,sets[3]]].flatMap(([n,s]) => [
            [n,"A",s.A.p1||"",s.A.p2||""],
            [n,"B",s.B.p1||"",s.B.p2||""],
            [n,"C",s.C.p1||"",s.C.p2||""],
          ])
        ];
        const csv = rows.map(r => r.map(cell => {
          const v = String(cell ?? "");
          return (v.includes(",")||v.includes('"')||v.includes("\n")) ? `"${v.replaceAll('"','""')}"` : v;
        }).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a"); a.href = url; a.download = `darts_lineup_${mode}.csv`; a.click();
        URL.revokeObjectURL(url);
      };

      const printPage = () => window.print();

      return (
        <div className="min-h-screen bg-gray-50 p-4 md:p-8">
          <style>{`@media print { body { -webkit-print-color-adjust: exact; print-color-adjust: exact; } .no-print { display: none !important; } .print\\:border-0 { border: 0 !important; } .print\\:shadow-none { box-shadow: none !important; } .print\\:bg-transparent { background: transparent !important; } }`}</style>

          <div id="print-root" className="max-w-5xl mx-auto space-y-6">
            <header className="flex flex-col md:flex-row md:items-center md:justify-between gap-3">
              <h1 className="text-2xl md:text-3xl font-bold">Darts Doubles — 3-Set Lineup</h1>
              <div className="flex flex-wrap items-center gap-3 no-print">
                <label className="text-sm">Mode</label>
                <select className="rounded-2xl border px-3 py-2" value={mode} onChange={(e)=>setMode(e.target.value)}>
                  <option value="home">Home</option>
                  <option value="away">Away</option>
                </select>
                <button onClick={applyHomeRules} className="px-3 py-2 rounded-2xl border hover:shadow">Apply HOME rules</button>
                <button onClick={applyAwayRules} className="px-3 py-2 rounded-2xl border hover:shadow">Apply AWAY rules</button>
                <button onClick={copy} className="px-3 py-2 rounded-2xl border hover:shadow">Copy</button>
                <button onClick={toCsv} className="px-3 py-2 rounded-2xl border hover:shadow">Export CSV</button>
                <button onClick={printPage} className="px-3 py-2 rounded-2xl border hover:shadow">Print / Save PDF</button>
              </div>
            </header>

            <SetCard setNo={1} value={sets[1]} onChange={(v)=>updateSet(1, v)} />
            <SetCard setNo={2} value={sets[2]} onChange={(v)=>updateSet(2, v)} coverageFrom={sets[1]} />
            <SetCard setNo={3} value={sets[3]} onChange={(v)=>updateSet(3, v)} coverageFrom={sets[1]} />

            <div className="rounded-2xl border bg-white p-4 md:p-6 space-y-3 print:border-0 print:shadow-none">
              <div className="flex items-center justify-between">
                <h3 className="font-semibold">Summary ({mode.toUpperCase()})</h3>
              </div>
              <pre className="text-sm bg-gray-100 rounded-xl p-3 overflow-x-auto whitespace-pre-wrap print:bg-transparent">{lineupText}</pre>
              <div className="text-xs text-gray-500">Coverage rule: Sets 2 & 3 must each include at least one player from <strong>each</strong> Set 1 pair (A, B, C). Use Apply HOME/AWAY to auto-fill, then tweak as needed.</div>
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
